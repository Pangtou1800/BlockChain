# 35 搭建迷你区块链（一）

    今天就来分享设计并实现一个迷你区块链的例子。

## 目标和范围

    考虑到我们无法搭建一个类似比特币的庞大的P2P网络，也没有太多时间实现一个完整的全节点钱包，
    所以我们将目标定为：构建一个仅包含基础功能的全节点客户端，简化UI和命令，包含功能如下：

        1.提供P2P节点发现和同步区块的能力
        2.提供创建公私钥对的功能
        3.提供发送交易的功能
        4.提供交易查询的功能
        5.提供余额查询的功能
        6.提供挖矿的功能，可以在任意地址上发起单机挖矿
        7.提供基础日志
    
    上面的7个功能基本涵盖了一个区块链全节点的主要功能，我主要讲解设计和实现思路。

## 技术选型

    区块链有四个核心技术概念：P2P网络、账户模型与存储、共识、加密模块。

    首先，P2P网络是区块链最底层的模块之一，这里主要考虑方便实现和测试，可选方案有轻量级
    消息队列和WebSocket。考虑到集成的便利性，我们首选WebSocket，因为至少需要一个
    HTTP JSON-RPC Server，我们可以复用Server中的WebSocket服务。

    除了通信协议之外，还要考虑数据交换格式，我们采用直接易懂的JSON格式，而不是像比特币一样
    的数据序列化格式。

    其次，我们来说说账户加密部分。ECDSA非对称加密模型过于复杂，我们就选用OpenSSL库中的
    RSA算法作为加密模块。而交易模型使用UTXO模型，因为状态模型可能需要维护状态，会带来额外的
    代码复杂度。

    再来说说数据存储，考虑到易用性和易读性，我选用SQLite3作为持久化存储。

    最后是共识算法。我们选用PoW作为共识算法，因为PoW实现起来十分简单，而且交易和区块的哈希计算
    会涉及到SHA-256，使用PoW算法就可以复用SHA-256的代码。

## 详细功能

    有了技术选型之后，我们再对目标功能点进行细分拆解。

        1.P2P网络：节点发现、节点维护、持久化保存、区块同步
        2.公私钥对：命令行，创建公私钥对并生成地址，提供私钥存储，公私钥验证
        3.发送交易：命令行，发送成功验证，输入是交易哈希
        4.交易查询：命令行，JSON格式的交易查询返回，输入是某个地址
        5.余额查询：命令行，JSON格式的余额查询返回，输入是某个地址
        6.挖矿：命令行，JSON格式挖矿信息返回，输入是某个地址
        7.区块共识：编织区块链的算法，包含创世区块以及调整全网挖矿难度
        8.交易共识：验证单个交易的算法，包含签名验证和UTXO验证
        9.基础日志：用于监控网络，区块验证等操作
        10.区块持久化存储：分叉与合并时的一致性，并为查询提供接口
        11.提供格式化输出交易的功能，格式主要指JSON格式
        12.有效防止双花交易
    
    通过详细的功能拆解我们发现功能点多达三十余个，如何设计实现这三十多个功能点就是接下来
    要解决的问题。我们先从顶层设计开始。

    最顶层是一个区块节点，也就是一个完整的可执行程序，命名为TinyChain，对应的命令行客户端为
    cli-tinychain。

    TinyChain的核心程序主要包含以下结构：

        tinychain
        -blockchain
        -consensus
        -database
        -network
        -httpserver
        -node
    
    我们以node作为最顶层，node启动则其他五个服务也连带启动。

    cli-tinychain主要包含以下结构：

        cli-tinychain
        -JSON
        -http-client
    
    命令行的构造相对简单，命令的解析和执行全都交由tinychain来完成，命令行只用httpclien把
    JSON形式的API包装起来既可。

    还有一些可以直接从现有的开发包集成的组件：

        基础组件
        -log
        -JSON-parser
        -sha256
        -key-pair
    

## 区块数据结构设计

    大致的顶层设计决定好之后，我们接下来为每一个模块填充一些数据结构。
    我们首先从最重要的区块开始。

    一个区块包含两部分，分别是区块头和区块体，区块头是一个区块的元数据，区块体是一个交易体的
    列表。

### 区块头的设计

    参考比特币，区块头包含了前向区块哈希、默克尔根哈希、时间戳、难度目标、Nonce值和版本号。

    结构示例如下：

        {
            "target_bits" : "4575460831240",
            "hash" : "4a9169e2f4f8673ac962...6954d25acacd92df",
            "merkle_tree_hash" : "3d228afc50bc52491f5d...f829790ea0b7635e5b4d44ab4f",
            "nonce" : "3852714822920177480",
            "height" : "1234567",
            "previous_block_hash" : "4d2544e044bfd2f342220a...1b1bc1ed6152ff5c7f3ff654",
            "time_stamp" : "1528070857",
            "transaction_count" : "1",
            "version" : "1"
        }

    ·target_bits - 当前区块的目标值
    ·hash - 当前区块的哈希
    ·merkle_hash_tree - 当前区块中交易列表的默克尔根
    ·nonce - 随机数
    ·height - 当前区块高度
    ·previous_block_hash - 前向区块哈希
    ·time_stamp - 生产这个区块时的时间戳
    ·transcation_count - 当前区块中包含交易数
    ·version - 区块的版本号（并非交易版本号）

    这里，我们的区块头大小不是固定的，也没有经过完整的序列化，是纯粹的JSON形式。
    所以也就不考虑字节印第安序的问题，也不考虑固定长度的问题。

### 区块体的设计

    区块体的设计其实就是交易体的设计，由于使用UTXO作为交易模型，我们先考虑一个输入、一个输出的
    结构。

        {
            "hash" : "8c14f0db3df150123e6f3d...ac1d1ff16284aefa3d06d87",
            "version" : "1",
            "input_size" : "1",
            "output_size" : "1",
            "size" : 135,
            "inputs" : [
                {
                    "prev_out" : {
                        "hash" : "0000000000000000000000000000000000000",
                        "index" : 0
                    }
                }
            ],
            "outputs" : [
                {
                    "value" : "5000000",
                    "address" : "f3e6066078e815bb2"
                }
            ]
        }

### 地址设计

    区块链地址都有通常意义上的地址，这里我们直接将公钥当做地址，不再进行哈希转换。

### 内存池

    内存池是指缓存交易的一块交易缓冲区，这里一个节点的主要处理对象，所以对内存池的管理
    是编织区块链的重要的一步，我们选用内存池标准库STL中的容器。

### 哈希计算

    区块和交易的哈希计算均使用SHA-256。

## 开发环境搭建

## 测试环境搭建
