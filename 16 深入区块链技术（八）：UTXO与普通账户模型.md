# 16 深入区块链技术（八）：UTXO与普通账户模型

    区块链网络中有两种记账模式，除了UTXO还有AccountBased结构，也就是普通的账户模型，
    也叫账户余额模型，前者在比特币系的数字货币中被广泛应用，后者更多是用在智能合约型的
    区块链上。

## 普通账户模型

    我们先从传统的账户模型出发来聊聊如何记账。

    假设有一个支付系统，在这个支付系统中有“村长”和“张三”两个账户，村长账户里有100万。
    现在村长要转账给张三10万，其中涉及的操作是这样的：

        1.检查村长的账户余额是否大于10万
        2.把村长的账户余额扣除10万变为90万，然后发送一笔转账消息给张三
        3.张三的账户接到转账消息，将张三的账户余额加10万
    
    可以看出，无论是村长还是张三，都有一个余额作为状态。也就是说当前的余额是记录在
    某个地方的，只需要读出来就可以了，这种设计就叫做账户余额模型。

    如果以上三个步骤发生在同一个中心化系统乃至同一个数据库中，那就非常简单，
    可以直接退化成一个事务，我们见到的银行账户、信用卡系统、证券交易系统、各种电商类应用、
    理财应用等基本都是一个中心化系统，最多也就是跨表跨数据库。

    如果以上步骤中，村长和张三的账户分属两个不同的系统，例如从A银行到B银行，
    就需要经过人民银行支付系统，即可信任的第三方来做中介。

    你可能发现了，在跨行转账的业务场景里，是没有办法做事务的，所以1和3不是同步的，
    如果3操作失败，还需要从2倒退到1的状态，这个情况叫做冲正交易。

    普通账户模型具有自定义数据类型的优点，但是却需要自己设计事务机制，也就是所谓的冲正交易。
    而UTXO模型则与之相反。

## UTXO模型

    UTXO - Unspent Transaction Output，未花费的交易输出。它的核心设计思路是无状态，
    它记录的是交易事件，而不是最终状态，也就是说只记录变更事件，用户需要根据历史记录
    自行计算余额。

    有点像MySQL中的binlog，主从模式的情况下，按照binlog来更新数据，Redis的AOF模式下
    备份模式也是如此。UTXO的思路也是类似的。

    把上面村长给张三转账的例子用记录交易本身的方式重新书写后过程如下：

        村长 100万 -> 张三 10万
                   -> 村长 90万

    这里一共有三条子记录，左边一条数输入，右边两条是输出。
    输入和输出共通组成了交易，它们需要满足一些条件：

        1.任意一个交易必须至少有一个输入、一个输出
        2.输入必须全部移动，不能只移动一部分
        3.输入金额 = 输出金额 + 交易手续费
    
    村长要交易时，首先构造交易的输入输出，然后再广播到全网，接收方自行判断交易是否属于自己。
    这里满足约束条件构成的交易模型，也就是UTXO模型。

## 余额模型 VS UTXO模型

    下面对比一下两种交易记录模型：

        1.存储空间，UTXO占用空间比账户模型高，因为账户模型只记录最终状态
        2.易用性，UTXO比较难以处理，账户模型则简单易理解。例如，UTXO模型在使用时，
            还需要配合高效的UTXO组装算法，尽可能减少输入输出的个数，还要让零钱归整，
            算法的复杂度显然高于余额模型
        3.安全性，UTXO模型比账户模型高。UTXO本身就具备ACID的记账机制，
            而账户模型则需要自行处理，比如重放攻击
    
    普通账户模型具有较高的自由度，可以让智能合约有更好的发挥空间；
    而且避免了UTXO复杂的组装逻辑，精度控制上也更加简单易行。

    UTXO似乎天然就是为数字货币设计的，具有较高频率的跨账户转移场景都比较适合UTXO模型。
    不过UTXO模型与智能合约并不能很好地兼容，这也就对开发者提出了更高的要求。

## 区块链中的UTXO模型

    我们借用比特币开发者文档中的UTXO模型说明来看看它实际的构造形式。

        -Transaction 0
            100k satoshis = input 0
            output 0 = 40k
            output 1 = 50k
        -Transaction 1
            40k(TX0 output 0) = input 0
            output 0 = 30k
        -Transaction 2
            50k(TX0 output 1) = input 0
            output 0 = 20k
            output 1 = 20k
        -Transaction 3
            30k(TX1 output 0) = input 0
            output 0 = 20k - UTXO
        -Transcation 4
            20k(TX2 output 0) = input 0
            10k = output 0
        -Transaction 5
            20k(TX2 output 1) = intput 0
            10k = output 0
        -Transacntion 6
            10k(TX4 output 0) = input 0
            10k(TX5 output 0) = input 1
            output 0 = 10K - UTXO   

    所有的交易都可以找到前置交易条目。只是TX3和TX6的交易输出还没有被花费。
    这里UTXO的含义就更加清晰了：Unspent Transaction Output，未花费的交易输出。

    这时候也就发现，UTXO同样可以表示余额：把一个地址上所有的UTXO都找出来，
    也就算出他的余额了。

    我们来看一个真是的例子，将二进制码解码为JSON格式后内容如下：

        {
            "hash":"89e80e14...3d2",
            "height":1093399,
            "inputs":[
                {
                    "address":"MLWtmjw...HX",
                    "previous_output":{
                        "hash":"770a72f...f06",
                        "index":0
                    },
                    "script":"[ 30440... ]",
                    "sequence":4294967295
                }
            ],
            "lock_time":"0",
            "outputs":[
                {
                    "address":"MGz9...iL",
                    "attachment":{
                        "type":"etp"
                    },
                    "index":0,
                    "locked_height_range":0,
                    "script":"dup hash160 [ 63ab00... ]",
                    "value":4500000000
                },
                {
                    "address":"MLWtmjw...HX",
                    "attachment":{
                        "type":"etp"
                    },
                    "index":1,
                    "locked_height_range":0,
                    "script":"dup hash160 [ 8a63941... ]",
                    "value":118082150283
                }
            ],
            "version":"2"
        }
    
    在一笔比特币交易中，很可能包含数个输入和数十个输出。而交易的输入和输出会影响交易大小，
    比特币的交易费是根据字节收费的，交易尺寸越大越贵；算法上则没有规定输入输出的个数，
    也没有规定区块的尺寸。

    在比特币中，将小于100kb的交易称为标准交易，超过100kb的交易称为非标准交易。
    它的前向input以及一个生成一个out约占用161~250bytes。所以在比特币中，大约的输入输出
    限制在600个左右（一个标准交易可包含的输入输出数）。

## UTXO的特性及缺点

    从计算的角度来说，UTXO具有非常好的并行支付能力，也就是上文中所说的如果没有尺寸限制，
    一笔交易可以包含任意个输入输出，同时也没有次序要求，同一笔交易中哪个UTXO在前在后
    是没有影响的。

    从存储的角度来说，UTXO具有较好的可裁剪特性。也就是说如果从最老的那一笔UTXO开始截断数据库，
    那么之前的数据是可以删除的。

    如果想进一步压缩数据尺寸，也可以在任意位置截断，记录UTXO对应的交易哈希即可。
    然后从其他节点获取并校验UTXO，这也是SPV轻钱包工作的基础之一。

    以太坊并没有使用比特币的这种UTXO的设计。这与以太坊构建通用计算的宗旨有关。

    V神指出了UTXO的缺陷，一共三类。

        ·可表达状态少。

            UTXO只能是已花费或者未花费状态，这就限制了需要其他内部状态的合约的生存空间。
            它意味着UTXO只能用于建立简单的、一次性的合约，更像是一个二进制控制为
        
        ·区块链盲点 - Blockchain Blindness
        
            UTXO脚本只能看到自己这条历史轨迹，无法看到区块链的数据全貌。
            这就导致了功能性扩展收到了限制，在花费比特币的过程中需要小心翼翼地组合UTXO，
            难以设计智能合约。
        
        ·价值盲点 - Value Blindness

            UTXO脚本不能提供非常精细的金额控制，基于账户模型的余额在花费过程中，
            可以任意地按值存取，仅取决于程序能够表达的最小精度。

            而UTXO要求必须全部移动，如果要满足一个目标金额，对组合UTXO算法的要求会比较高。
            一方面要求尽可能地精确，另一方面又要求输入输出数量尽可能小。

    UTXO是比特币上的原生设计，在区块链以前并没有这种逻辑数据结构，它的出现给了人们看待
    数据转移的不同视角，但UTXO不是所有区块链所必需的，公开链开发过程中是否选用UTXO模型可以
    根据业务场景进行判断。