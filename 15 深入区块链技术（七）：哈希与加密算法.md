# 15 深入区块链技术（七）：哈希与加密算法

    区块链最核心的两个技术点是共识机制和密码学，前面重点讲解了共识机制。
    接下来讲一讲密码学，而区块链密码学只要了解它的基本原理和优劣即可。

    区块链中主要有两类密码学算法，第一类是哈希算法，第二类是非对称加密算法。

## 哈希算法

    哈希算法是一类数学函数算法，又称散列算法，它是一种数据映射关系。

    为了方便举例，我们假设h=HASH(X|z)，你输入一个任意长度的数据z，经过哈希运算后，
    返回给你固定长度的数据h。z叫做原像，h叫做哈希结果，又称作“数据指纹”，
    z可选的数据集合构成了X。

    哈希算法有下面的4种特性：

        1.原像不可逆。原像不可逆是指对于任意的h，都无法根据h自身的信息推导出Z
        2.难题友好性。难题友好性通俗的理解就是没有简便方法，对于谁来说都是需要付出算力的难题。
        3.发散性。发散性是指对于任意的z，只要改变很少的信息量，例如改变1个比特位生成z'，
            计算出来的哈希值就会大相径庭
        4.抗碰撞性。抗碰撞性是指对于任意两个不相同的z，那么他们对应的h值也不同。
            如果满足：对于任意的y不等于z，则HASH(y)不等于HASH(z)，则称为严格抗碰撞性；
            如果满足：对于给定的y，无法找到另外的z使HASH(z)=HASH(y)，则称为弱抗碰撞性。
    
    目前流行的Hash算法包括了MD5、SHA-1和SHA-2，其中MD5被证明不具有强抗碰撞性。
    SHA（Secure Hash Algorithm）是一个哈希函数族，分为1~3代标准，目前使用比较多的是SHA-2系列。

    第一代的SHA-1基于MD4设计，并且模仿了该算法，SHA-1已经被证明了不具备“强抗碰撞性”，
    所以安全性不够高。

    为了提高安全性，第二代SHA-2一共包含了SHA-224、SHA-256、SHA-384和SHA-512算法，
    他们跟SHA-1算法原理类似。SHA-3相关算法也已经被提出，它的出现也并不是要取代SHA-2，
    而且SHA-2算法也没有明显的弱点。

    由于对MD5、SHA-1算法出现了成功的破解，我们需要一个不同于之前的算法，可替换的加密散列算法，
    这才有了SHA-3。

### 1.1 区块链上的哈希算法

    哈希算法被广泛地应用在构造和验证区块、交易的完整性上，由于哈希算法的四个特性，
    使得我们可以把任意的交易数据做成数据摘要，然后再一个一个地链接起来，形成数据块的链式结构。

    这样我们可以通过验证每个区块间接地验证交易，然后每个交易元数据也可以做成哈希数据摘要，
    用于验证交易数据的完整性。

    每个当前区块里面包含了上一个区块的哈希，形成一个哈希指针链表，由于哈希算法的发散性，
    所以这个链表也有极大的发散性。

    我们可以用代码模拟一遍，列表构造5个简单的区块，其中第一个区块是创世区块，
    我们规定它指向的前向区块的哈希是全零。

    后面第2个块、第3个块中，content分别记录了两笔交易，这里为了方便理解我使用了字符串，
    区块链的交易实际上是二进制格式化的数据而非文本。代码中并没有填充哈希，
    哈希值是运行时填充的。


        import hashlib

        def main():
        block_headers=[
            {"prev_block_hash":"000...000","content":"genesis block:A pay C 12.3 BTC"},
            {"prev_block_hash":"to_be_hashed","content":"2nd block:C pay B 2.0 BTC"},
            ...
            {"prev_block_hash":"to_be_hashed","content":"5th block:transactions..."}
        ]

        index = 0
        for header in block_headers:
            if index == 0
                print header
                index = index + 1
                continue
            
            prev_block_header = block_headers[index - 1]
            target_buffer = prev_block_header["content"] + 
                                prev_block_header["prev_block_hash"]
            header["prev_block_hash"] = hashlib.sha256(target_buffer).hexdigest()
            print header
            index = index + 1
        
        if __name__ == '__main__':
            main()
    
    这是一个典型的哈希指针链表，每一个区块的prev_block_hash域都指向上一个区块哈希。
    如果把2nd block中的2.0改成2.1，那么之后的所有区块结果都会大不相同。

    上面是一个极简的区块链基本结构，区块头描述了一个区块的基本信息，在实际应用里，
    区块头中通常包含下面几个内容：

        区块序号 - 哈希 - 交易号 - Nonce - MixHash - 版本 - 难度 - 
            默克尔树哈希 - 前一区块哈希 - 出块时间
    
    前一区块哈希是一个区块头必备的数据域，这样的链式结构具有发散传导性，
    越历史久的区块被篡改，影响的范围就越大，这也叫做历史逆向修改困难。

### 1.2 默克尔树 - Merkle Tree
    
    先来看看什么是默克尔树。

    默克尔树是一种二叉树，由一组叶子节点、一组中间节点和一个根节点组成。
    从最底部开始，D0, D1, D2, D3就是叶子节点包含的数据。对应的，
    N0, N1, N2, N3就是叶子节点的值，分别按照N0=Hash(D0)计算而来。
    接着往上，N4=Hash(N0+N1)；N5=Hash(N2+N3)。最后，Root=Hash(N4+N5)。

    我们可以看到，默克尔树最下面的大量的叶子节点包含基础数据，每个中间节点都是
    它的两个叶子节点的哈希。根节点也是它两个子节点的哈希，代表了默克尔树的顶部。

    总结一下默克尔树的特点:

        ·首先，默克尔树常见的结构是二叉树，但它也可以是多叉树，它具有树结构的全部特点
        ·默克尔树的基础数据是不固定的，存任何数据都行，它自身则只保存计算得到的哈希值
        ·默克尔树是从下往上逐层计算的，叶子节点是基础

    那么如何用默克尔树验证一笔交易呢？

        [6C0A]
            -[5C71]
                -[EC20]
                    -BQ3W:5
                    -CX7J:27
                -[781A]
                    -[1FXQ]:18
                    -[9DOG]:64
            -[8F74]
                -3B95
                    -ZUFE:30
                    -JX5R:2
                -0D16
                    -YO3G:43
                    -VCC1:48
    
    假设我们要验证9DOG:64的交易，我们仅需要知道从这个节点回溯到根节点路上的所有
    另一个中间节点即可（1FXQ、EC20、8F74），如果最终计算得到的值与区块头中记录的哈希（6C0A）
    一致，则说明这笔交易确实存在于区块中。

    在比特币中，所有交易信息和它们构成的默克尔树就存在区块体里，而默克尔树的根则
    存放在区块头中。

    以太坊中针对比特币的设计做了改进，叫做默克尔帕特里夏树（Merkle Patricia Tree），
    相比于比特币在块头中只有一颗树，以太坊有三棵树。

    除此之外，区块链的挖矿算法也使用了哈希算法，在此不再赘述。

## 非对称加密算法

    非对称加密算法是相对于对称算法而言的，这两者组成了密码学的核心内容。

    这两者的区别体现在秘钥是否可以公开。
    对称加密要求加解密过程都使用相同的秘钥，而非对称加密可以提供一对秘钥，
    私钥自己保管，公钥可以公开。

    常见的对称加密算法有DES、3DES、AES、IDEA，常见的非对称加密算法RSA、ECC等。
    在比特币等众多数字货币的项目中，在账户层面主要使用非对称加密算法。

    在对称加密算法里，由于双方需要提前共享秘钥，在使用过程中有诸多不便；
    而非对称加密算法的出现则解决了这一难题。

    在非对称算法中，私钥一般是通过一个随机数产生的，这个随机数我们也叫种子。
    从这个角度来说，知道了这个随机数也就等于知道了私钥，不过私钥的产生范围非常大，
    在比特币中是2的256次方，差不多在10的70次方数量级上。

    所以区块链对产生随机数的算法要求比较高，它要求真实的均匀随机分布，
    而不是计算机伪随机数。

    如果我们有了私钥，接下来就如图所示：

        -256 bit private key
            ecsda
        -ecsda public key
            sha256
            ripemd160
        -public address
            base58
        -Bitcoin Address
    
    从私钥到公钥，是由非对称算法保证的，比特币种这种算法选择为ECDSA，ECDSA中选择的
    椭圆曲线名为secp256k1。

    而从公钥到地址则使用了哈希算法，在这一步使用了SHA256和RIPEMD160。
    椭圆曲线加密算法ECC利用了“寻找离散对数”的难解性提供了单向不可逆性。

    在区块链上，一个比特币交易的产生由两部分组成。

    第一部分是签名加锁，对应到的是交易的输出；第二部分是解锁花费，对应到的是交易的输入。
    当我们构造一笔交易的时候必然会用到私钥，这也是所有数字货币资产控制权由私钥保证的
    根本原因。

    最后来谈谈量子威胁的内容。很多人都认为量子计算机的强大算力威胁到了哈希的抗碰撞性。
    不过我个人认为这不是一个设计缺陷，而是一个发展问题，是可以在区块链的发展过程中解决的。

    我的看法如下：

        1.即使出现了量子计算机攻破了非对称加密算法，那也要看是什么算法，
            是ECC，还是RSA
        2.其次要看攻击成本是否足够低，理论可行性不等于工程可行性
        3.量子计算威胁的对象不止加密货币，而是整个密码学习题。
            如果发生了破解事件，那么首当其冲的其实是银行、互联网后端系统，
            毕竟当前整个互联网都是在HTTPS的基础上建立的。
        4.量子计算机目前虽然发展喜人，但是离实际应用还是有很长时间